module Semantics (
    deSugar,
    dsExpr,
) where

import Syntax
import General

lispTrue = ELit (Atom "#t")
lispFalse = ELit (Atom "#f")

deSugar :: Value -> File
deSugar Nil = []
deSugar (bind :. rest) = dsBinding bind : deSugar rest

dsBinding (Atom "define" :. Atom var :. binding :. Nil) = Binding var $ dsExpr binding
dsBinding x = throwEx $ "malformed binding " ++ show x

--allow mapping over scheme lists
scmMap :: (Value -> a) -> Value -> [a]
scmMap f (l :. r) = f l : scmMap f r
scmMap _ Nil = []
scmMap _ x = throwEx $ show x ++ " is not a list"

dsBind (Atom v :. expr :. Nil) = Binding v $ dsExpr expr
dsBind bad = throwEx $ "malformed binding " ++ show bad

dsExpr all@(Atom "lambda" :. args :. body :. Nil) = dsLam args body
    where dsLam Nil body = dsExpr body
          dsLam (Atom a :. as) body = EAbs a $ dsLam as body
          dsLam _ _ = throwEx $ "malformed lambda " ++ show all

dsExpr bad@(Atom "lambda" :. _) = throwEx $ "malformed lambda " ++ show bad

dsExpr (Atom "if" :. test :. body1 :. body2 :. Nil) =
    ECase [Alt (dsExpr test) (dsExpr body1), Alt lispTrue (dsExpr body2)]

dsExpr bad@(Atom "if" :. _) = throwEx $ "malformed if " ++ show bad

dsExpr (Atom "cond" :. body) = ECase $ scmMap dsAlt body
    where dsAlt (c :. b :. Nil) = Alt (dsExpr c) (dsExpr b)
          dsAlt bad = throwEx $ "malformed condition " ++ show bad

dsExpr (Atom "let" :. bindings :. expr :. Nil) = ELet (scmMap dsBind bindings) (dsExpr expr)
dsExpr (Atom "let" :. bad) = throwEx $ "malformed let " ++ show bad

dsExpr (Atom "let*" :. bindings :. expr :. Nil) = dsBind' bindings
    where dsBind' (b :. bs) = ELet [dsBind b] (dsBind' bs)
          dsBind' Nil = dsExpr expr
          dsBind' bad = throwEx $ "malformed binding " ++ show bad

dsExpr (Atom "let*" :. bad) = throwEx $ "malformed let* " ++ show bad

dsExpr (Atom "letrec" :. bindings :. expr :. Nil) = ELetRec (scmMap dsBind bindings) (dsExpr expr)
dsExpr (Atom "letrec" :. bad) = throwEx $ "malformed letrec " ++ show bad

dsExpr (Atom "quote" :. expr :. Nil) = ELit expr
--don't need well-formedness check, this is generated by parser

--function call
dsExpr (fun :. args) = dsFun (dsExpr fun) args
    where dsFun ex (arg :. args) = dsFun (EApp ex (dsExpr arg)) args
          dsFun ex Nil = ex

dsExpr lit@(Atom l)
    | head l == '#' = ELit lit
    | l == "else" = lispTrue
    | otherwise = EVar l
dsExpr l@(Number _) = ELit l

dsExpr Nil = ELit Nil

dsExpr x = throwEx $ "internal error - unexpected form \n" ++ show x
